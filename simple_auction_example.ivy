#lang ivy1.7

# sorts
type txn_cnt
type money
type item
type txn_id

# interpretations 
interpret txn_cnt -> nat
interpret money -> nat
interpret item -> bv[16]
interpret txn_id -> nat

# state relaltions and functions 
# (global)
relation placed_bid (I:item, M:money)
function max_bid (I:item) : money


# (txn local)
function arg_item (T:txn_id) : item
function arg_money (T:txn_id) : money
function old_max (T:txn_id) : money
function counter (T:txn_id) : txn_cnt


# locks


# init action
after init {
  placed_bid (I, M) := false; 
  max_bid (I) := 0;
  old_max (T) := 0;
  counter (T) := 0;
}

# actions
action invoke (t: txn_id, i:item, m:money) = {
  require counter (t) = 0;
  arg_item(t) := i;
  arg_money(t) := m;
  counter (t) := 1;
}


action new_bid_fst (t:txn_id) = {
  require counter(t) = 1;
  var i := arg_item(t);
  old_max(t) := max_bid(i);
  counter(t) := 2;
}

action new_bid_snd (t:txn_id) = {
  require counter(t) = 2;
  var m := arg_money(t);
  var i := arg_item(t);
  # the following requirement is satisfied when running under serializability and hence the verification passes
  # it is however not guaranteed under weaker isolation models and hence the verification fails
  require max_bid(i) = old_max(t);

  placed_bid (i,m) := true;
  if  m > old_max(t) {
    max_bid(i) := m;
  }
  counter(t) := 3;
}

action commit (t:txn_id) = {
  require counter(t) = 3;
  counter(t) := 4;
}


# invariants
invariant placed_bid(I,M) -> max_bid(I) >= M
#invariant  arg_item(T) = I -> old_max(T) = max_bid(I)


# exports to the environment
export new_bid_fst
export new_bid_snd
export commit
export invoke
